<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // this的面试题
    /*function Fn() {
        console.log(this);
    }
    Fn();//window 普通函数调用模式
    new Fn();//{}  构造函数调用模式
    Fn.apply(Fn);// Fn的函数体   方法借用模式*/


    //2
    /*var o = {
        f: function () {
            console.log(this);
        },
        2: function () {
            console.log(this);
/!*            console.log(this.__proto__===o[2].prototype)*!/
        }
    };
    o.f();//o   对象调用模式
    o[2]();//o  对象调用模式
    new o[2]();//存疑，存在着优先级的问题 {}  通过构造函数模式进行调用
    o.f.call([1, 2]);//[1,2]   call方法进行方法借用。
    o[2].call([1, 2, 3, 4]);// [1,2,3,4]  call方法进行方法借用*/


    //3
    /*var name = 'out';
    var obj = {
        name: 'in',
        prop: {
            name: 'inside',
            getName: function () {
                return this.name;
            }
        }
    };

    console.log(obj.prop.getName());// inside
    var test = obj.prop.getName;//把test这个变量指向了obj.prop.getName所在的内存地址。
    console.log(test());//如果一个函数之前没有被一个对象进行调用，则它是通过普通函数调用模式进行调用的，因此内部的this是window   输出window.name   'out'
    console.log(obj.prop.getName.apply(this));//window.name  'out'*/

    // 4
    var length = 10;
    function fn() {
        console.log(this.length);
    }
    var obj = {
        length: 5,
        method: function (f) {
            console.log(this);
            f();// f在调用的时候是什么调用模式？普通函数调用模式  window.length  10
            arguments[0]();// 通过什么模式来进行调用的。
            //arguments是一个类数组，也就是一个对象，就是通过arguments来进行调用的
            //arguments.length实参的数量。实参长度是1     1
            arguments[0].call(this);
            // 调用method方法是通过obj.method 因此在这里的this就是 obj
            //通过call方法把fn内的this指向了obj
            // 输出obj.length  5
        }
    };
    obj.method(fn);

</script>
</body>
</html>