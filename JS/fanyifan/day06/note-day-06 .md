## 创智播客 前端与移动开发学院 javascript面向对象编程与高级

## 复习

思考题：
```
if(!"a" in window){
    var a = 123;
}
console.log(window.a)
//in操作符的作用:判断一个属性在不在对象或者对象的原型链上，不管这个属性的值是不是undefined
```
### 闭包

#### 闭包的概念


计算机科学中的闭包
```
在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。

这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。
所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。

简单理解（基本）
函数可以形成作用域。这个作用域就是闭包

```

《js权威指南》中的闭包

```
和其他大多数现代编程一样，JS也采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，
而不是函数调用时决定的。
js的作用域是词法作用域，只跟何时被创建有关系，跟在何地被调用没有关系。

为了实现这种词法作用域，JS函数对象的内部状态不仅包含函数的代码逻辑，还必须保存了当前的作用域链的信息。


闭包概念：函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为"闭包"。


//一个函数不管在何时被调用，它的作用域链都是已经被固定好了的。
从技术的角度讲，所有的JS函数都是闭包：它们都是对象，它们都关联到作用域链。定义大多数函数时的作用域链在调用函数时依然有效，但这并不是我们通常意义上的闭包。
当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域时，事情就变得非常微妙。(这种情况是我们js通常意义上的闭包，
也是我们提到闭包这一概念所指的闭包)

当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。
有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在JS中非常常见。
```

#### 闭包的作用

总的来说就是突破作用域限制，访问到作用域内部的变量。

- 在函数外界对函数内部变量进行查询，修改操作

- 实现缓存


#### this指向的问题

全局中的this指向了window，这种情况没必要讨论，我们主要去研究在函数中的this指向了谁。


- 函数调用模式
一个普通函数在调用的的时候内部的this指向了window。
- 对象方法调用模式
```
    哪个对象调用了方法，这个方法内部的this就指向了谁。
    obj.fn()
    btn.onclick=function(){}
    ary[0]()
    思考：原型上的方法被实例调用，this指向了谁？
```
- 构造函数调用模式
```
    构造函数内部的this指向了被创建出来的实例
```
·使用无new的方式用构造函数创建一个实例
```
function Person(){
    if(this===window){
        return new Person()
    }
}
var a = Person();
```
- 上下文调用模式（方法借用模式）

·call 会改变this指向，第一个参数为this指向的目标，
剩下的参数通过字符串的形式传递
```
var obj = {}
function fn(a,b){
    console.log(a,b)
    console.log(this)
}
fn.call(obj,'a','b')
```

·apply 改变this指向，第一个参数是this指向的目标，剩下的参数通过数组或者类数组的形式传递
```
var obj = {}
function fn(a,b){
    console.log(a,b)
    console.log(this)
}
fn.apply(obj,['a','b'])
```
·bind 预先改变this指向，剩下的参数通过字符串的形式传递

```
var obj = {}
function fn(a,b,c){
    console.log(a,b,c);
    console.log(this)
}
var f = fn.bind(obj,'a','b');//使用bind方法的时候fn并不会执行，只会对fn进行预处理，返回一个新的函数。
f('c')//新的函数执行的时候，可以再次传入剩余的参数。
```

### 科里化与反科里化
·科里化
```
传入部分参数，返回一个接受剩余参数的函数，目的是为了一个函数缩小适用范围，使其针对性更强。 bind就是科里化思想的一个方法。
```
·反科里化
```
反科里化与科里化相反，是制造一个新的函数，这个函数可以适用于更广的范围。
```










